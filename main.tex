\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acronym}
\usepackage{hyperref} % links
\usepackage{comment} % for multi-line comments
\usepackage{booktabs} % for better tables
\usepackage{xcolor}
\usepackage{listings}

\lstdefinestyle{yaml}{
     basicstyle=\color{blue}\footnotesize,
     rulecolor=\color{black},
     string=[s]{'}{'},
     stringstyle=\color{blue},
     comment=[l]{:},
     commentstyle=\color{black},
     morecomment=[l]{-}
 }

\showboxdepth=5
\showboxbreadth=5

\school{\unibo}
\programme{Corso di Laurea Magistrale in Ingegneria e Scienze Informatiche}
\title{Fancy Title}
\author{Penazzi Paolo}
\date{\today}
\subject{Supervisor's course name}
\supervisor{Prof. Supervisor Here}
\cosupervisor{Prof. CoSupervisor 1}
\session{III}
\academicyear{2022-2023}

% Definition of acronyms
\acrodef{CAS}{Collective Adaptive System}
\acrodef{vm}[VM]{Virtual Machine}
\acrodef{SUT}{System Under Test}


\mainlinespacing{1.241} % line spacing in main matter, comment to default (1)

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	
Max 2000 characters, strict.
\end{abstract}

%----------------------------------------------------------------------------------------
\tableofcontents   
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
%----------------------------------------------------------------------------------------

\begin{comment} 
Write your intro here.
\sidenote{Add sidenotes in this way. They are named after the author of the thesis}

You can use acronyms that you defined previously,
such as \ac{IoT}.
%
If you use acronyms twice,
they will be written in full only once
(indeed, you can mention the \ac{IoT} now without it being fully explained).
%
In some cases, you may need a plural form of the acronym.
%
For instance,
that you are discussing \acp{vm},
you may need both \ac{vm} and \acp{vm}.

\paragraph{Structure of the Thesis}

\note{At the end, describe the structure of the paper}

\end{comment}

%----------------------------------------------------------------------------------------
\chapter{Motivation, Background and Related Work}
%----------------------------------------------------------------------------------------

In every field of engineering, testing is a fundamental part of the development process.
It is used to verify that the system meets the requirements and to assure that it has the desired quality.

A \textit{testbed} is a platform for experimentation and testing. 
It provides a rigorous, transparent and replicable environment for testing.
Testbed often makes use of simulators, which are software that allows the user to see how its program would behave in a real environment.

In computer science research, is important to evaluate the behavior of newly developed algorithms against state-of-the-art solutions.
This allows us to understand whether a newly developed solution is better than an existing one in a certain scenario.

To make this comparison \textit{benchmarks} are used. A benchmark is a reference against which a solution can be compared.

This work targets a specific category of systems, called \ac{CAS}.

% Definition of CAS
A \ac{CAS} is composed of a large number of entities that interact with each other and with the environment to achieve a common goal.
They are part of a wider category of systems called \textit{Self-Adaptive Systems}.

% Example of CAS both in nature and in artificial systems
Examples of \ac{CAS} can be found both in nature and in artificial systems.
In nature, a colony of ants is a \ac{CAS}, where each ant is an autonomous entity that interacts with other ants and with the environment 
to achieve the common goal of the colony. 
Other examples are bird flocks, fish shoals, animal herds, human crowds etc.
Regarding artificial systems, some examples are cars on streets, drone swarms, and many more. \cite{2}

% Characteristics of CAS
All these systems share some common characteristics:
\begin{itemize}
    \item \textbf{Self-Adaptive:} The system can adapt to changes in the environment without requiring an outside entity to control it.
    \item Adaptation to the environment is not carried out by a single entity - but rather emerges by the interaction of several entities. \cite{3}
\end{itemize}

We are interested in the different properties of these systems. Most of these can be measured by carrying out tests.

%----------------------------------------------------------------------------------------
\chapter{Domain Analysis}
%----------------------------------------------------------------------------------------

\section{Ubiquitous Language}

To better understand the problem domain and to avoid misunderstandings, a ubiquitous language was defined.

\begin{table}[h]
    \centering
    \begin{tabular}{|l|p{0.8\textwidth}|}
    \toprule
    \textbf{Term} & \textbf{Meaning} \\
    \midrule                                                                                                                                                              
    Testing & The overall process carried out to verify and validate a system, according to requirements, to promote the desired internal and external quality and to mitigate risks in development and products. \\ \hline
    Testbed & A platform for rigorous transparent and replicable environment for experimentation and testing TODO Cite \\ \hline
    Solution & A set of algorithms leading to achieving goals and overcoming the problem posted \\ \hline
    Scenario & Contains all the information about the test execution: the simulation platform, the metrics, the input parameters \\ \hline
    Program & TODO \\ \hline
    Simulator & A software that allows the user to see how its program would behave in a real environment \\ \hline
    Parser & Component of the Testbed responsible for the read of the input file \\ \hline
    Listener & Component of the Testbed responsible for the read of the output of the simulator \\ \hline
    \end{tabular}
    \caption{Domain Ubiquitous Language}
    \end{table}

\section{Technologies}

\subsection{Containerization}

% What is containerization
Containerization is a lightweight alternative to full-machine virtualization that involves encapsulating an application in a container with its operating environment.

% Why containerization is needed
The main reason for using containerization is to create a consistent, isolated environment for applications to run in.
By doing so, the user can be sure that the application will always run the same way, regardless of the user's machine configuration. 
Further, this allows the user to focus solely on the application itself, without having to worry about dependencies, software updates, compatibility and things like this.

% Choice of Docker as containerization technology
When choosing a containerization technology, the choice was between the two most popular solutions in this field: Docker and Kubernetes.
Ultimately, Docker was chosen because it is more lightweight and easier to use than Kubernetes.

% How Docker works
Docker is a platform for building, running, and shipping applications in containers.
Docker containers wrap up a piece of software in a complete filesystem that contains everything it needs to run:
code, runtime, system tools, system libraries - anything you can install on a server.
To create a container, a Dockerfile is needed, which is a text document that contains all the information to deploy the application.

\subsection{Language}
Different languages were considered for the implementation of the system.

\paragraph*{Scala}
Scala is a strong statically typed high-level general-purpose programming language that supports both object-oriented 
programming and functional programming. 
Designed to be concise, scalable and safe, many of Scala's design decisions are aimed at addressing criticisms of Java.
\cite{1}
One weakness of Scala is its steep learning curve, which makes it difficult to learn for new users.

\paragraph*{Kotlin}
Kotlin is a cross-platform, statically typed, general-purpose high-level programming language with type inference. 
Kotlin is designed to interoperate fully with Java.
Support for multiplatform programming is one of Kotlinâ€™s key benefits. It reduces time spent writing and maintaining 
the same code for different platforms while retaining the flexibility and benefits of native programming.
%[https://github.com/JetBrains/kotlin]

\paragraph*{Rust}

Rust is a multi-paradigm programming language designed for performance and safety, especially safe concurrency. \\
It has been designed to be a safe, concurrent, practical language, supporting functional and imperative-procedural paradigms.
It is considered the modern version of C and C++.

\paragraph*{Final choice}
After a brief analysis, it was clear that both Kotlin and Scala were suitable candidates for the implementation of the system.
In the end, the choice fell on Kotlin.

%----------------------------------------------------------------------------------------
\chapter{Design}
%----------------------------------------------------------------------------------------

\section{Architecture}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/architecture.png}
    \caption{Architecture of the system (v0.1)}
    \label{fig:random-image}
\end{figure}

\paragraph*{User Interaction} From an early analysis the better choice seems to be to deploy the framework online.
This means that the user doesn't have to install anything, but can use the framework by visiting the webpage.
(A step further would be using \href{https://kotlinlang.org/docs/multiplatform.html#kotlin-multiplatform-use-cases}{Kotlin Multiplatform} to deploy the framework for different platforms)

\paragraph*{Frontend} The frontend consists of a web page that allow the user to interact with the software. 
A minimum interface has a button to load an input file (YAML), a button to start the simulation, and a box to show the results.

\paragraph*{Volume} A persistent data storage volume to keep all the input and output files in memory.

\paragraph*{Controller} When the user start the simulation, it uses a parser to read the input file, create the simulation properties,
and starts the simulator-specific executor.

\subsection{Parser} 
The parser is responsible for reading the input file and creating the simulation model.

\paragraph*{Executor} The executor is responsible of the start of the simulation. It should be able to drive different simulators.

\paragraph*{Listener} The listener read the output of the simulation and send it to the frontend.
(In the image it is created by the executor but actually it may be the controller that creates the listener)

\subsection{Input Files}

One of the main challenges of this work is to create a flexible system that can be extended to support different simulators.
This means that the input file structure should take into account the possibility of being extended, without breaking the existing structure.

This is an input file example, which will be used to explain the structure of the input file.

\begin{lstlisting}[style=yaml]
strategy:
  multiThreaded: false
  executionOrder:
    - grid-random
    - grid-gradient

simulators:
  - name: Alchemist
    version: "28.0.1"
    scenarios:
      - name: grid
        description: A tutorial to Alchemist and Protelis incarnation
        scenarioConfiguration: "src/main/yaml/grid.yml"
        programs:
          - name: gradient
            description: A gradient program
            input: "src/main/yaml/gradient.yml"

          - name: random
            description: A random program
            input: "src/main/yaml/random.yml"
\end{lstlisting}

\subsection{Model}
The testbed model should follow the input file structure. 
This allows the Parser to convert the YAML file directly into the testbed model.

TODO add image

As can be seen from the image, the model is 1:1 with the input file.

%----------------------------------------------------------------------------------------
\chapter{Implementation}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\chapter{Evaluation}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\chapter{Conclusion and Future Work}
%----------------------------------------------------------------------------------------

\begin{comment}

I suggest referencing stuff as follows: \cref{fig:random-image} or \Cref{fig:random-image}

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/random-image.pdf}
    \caption{Some random image}
    \label{fig:random-image}
\end{figure}

\section{Some cool topic}

You may also put some code snippet (which is NOT float by default), eg: \cref{lst:random-code}.

\lstinputlisting[float,language=Java,label={lst:random-code}]{listings/HelloWorld.java}

\section{Fancy formulas here}

\end{comment}

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter

\nocite{*} % comment this to only show the referenced entries from the .bib file

\bibliographystyle{alpha}
\bibliography{bibliography}

\end{document}
